import cv2
import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np
import gudhi as gd

class CmapLoss(nn.Module):
    def __init__(self, weight: float = 1.0, reduction: str = 'mean'):
        super(CmapLoss, self).__init__()
        self.weight = weight
        self.reduction = reduction
        
    def forward(self, cmap_gt: torch.Tensor, path_pred: torch.Tensor):
        loss = cmap_loss_logits(cmap_gt, path_pred, self.reduction)
        return self.weight * loss

def cmap_loss(cmap_gt: np.ndarray, path_pred: np.ndarray) -> torch.Tensor:
    """
    Compute the dot product loss between a ground truth cold map and a predicted path.
    Args:
        cmap_gt (np.ndarray): Ground truth cold map as a NumPy array.
        path_pred (np.ndarray): Predicted path as a NumPy array.
    Returns:
        torch.Tensor: The computed loss as a torch.Tensor.
    """
    cmap = torch.from_numpy(cmap_gt).float()
    cmap_f = torch.flatten(cmap)
    
    path_np = np.array(path_pred)
    path_t = torch.from_numpy(path_np).float()
    path_f = torch.flatten(path_t)
    
    return torch.dot(cmap_f, path_f)

def cmap_loss_torch(cmap_gt: torch.Tensor, path_pred: torch.Tensor, reduction: str = 'mean') -> torch.Tensor:
    """
    Compute the dot product loss between a ground truth cold map and a predicted path.
    Args:
        cmap_gt (torch.Tensor): Ground truth cold map as a torch.Tensor.
        path_pred (torch.Tensor): Predicted path as a torch.Tensor.
    Returns:
        torch.Tensor: The computed loss as a torch.Tensor.
    """
    cmap_f = torch.flatten(cmap_gt)
    path_f = torch.flatten(path_pred)
    
    loss = torch.dot(cmap_f, path_f)
    
    return loss if reduction != 'mean' else loss / len(cmap_f)

def cmap_loss_logits(cmap_gt: torch.Tensor, path_pred: torch.Tensor, reduction: str = 'mean') -> torch.Tensor:
    """
    Compute the dot product loss between a ground truth cold map and a predicted path.
    Args:
        cmap_gt (torch.Tensor): Ground truth cold map as a torch.Tensor.
        path_pred (torch.Tensor): Predicted path as a torch.Tensor.
    Returns:
        torch.Tensor: The computed loss as a torch.Tensor.
    """
    cmap_f = torch.flatten(cmap_gt)
    
    path_pred = torch.sigmoid(path_pred)
    path_f = torch.flatten(path_pred)
    
    loss = torch.dot(cmap_f, path_f)
    
    return loss if reduction != 'mean' else loss / len(cmap_f)

def cmap_loss_logits2(cmap_gt: torch.Tensor, path_pred: torch.Tensor, reduction: str = 'mean') -> torch.Tensor:
    path_pred = torch.sigmoid(path_pred)
    loss = (cmap_gt * path_pred).sum()
    if reduction == 'mean':
        loss = loss / cmap_gt.numel()
    return loss


class BCELoss(nn.Module):
    """
    Binary Cross-Entropy Loss with an optional weighting factor.
    Args:
        weight (float, optional): A weighting factor to scale the loss. Default is 1.0.
        
    Methods:
    
        forward(path_gt: torch.Tensor, path_pred: torch.Tensor, reduction: str = 'mean') -> torch.Tensor:
            Computes the weighted binary cross-entropy loss between the ground truth and the predictions.
            Args:
                path_gt (torch.Tensor): Ground truth tensor.
                path_pred (torch.Tensor): Predicted tensor.
                reduction (str, optional): Specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. Default is 'mean'.
            Returns:
                torch.Tensor: The computed weighted binary cross-entropy loss.
    """
    def __init__(self, weight: float = 1.0):
        super(BCELoss, self).__init__()
        self.weight = weight
        
    def forward(self, path_gt: torch.Tensor, path_pred: torch.Tensor, reduction: str = 'mean'):
        loss = bce_loss_logits(path_gt, path_pred) #, reduction)
        return self.weight * loss

def bce_loss(path_gt: str, path_pred: str, reduction: str = "mean") -> float:
    """
    Calculate Binary Cross Entropy (BCE) loss between two black and white images using OpenCV.
    
    Args:
        ground_truth_path (str): Path to the ground truth image containing a path (black and white).
        prediction_path (str): Path to the prediction image generated by a model (black and white).
        reduction (str): Specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. Default: 'mean'.
        
    Returns:
        float: The BCE loss value between the two images.
    """
    ground_truth_img = cv2.imread(path_gt, cv2.IMREAD_GRAYSCALE)
    prediction_img = cv2.imread(path_pred, cv2.IMREAD_GRAYSCALE)
    
    if ground_truth_img is None:
        raise ValueError(f"Failed to load ground truth image from {path_gt}")
    if prediction_img is None:
        raise ValueError(f"Failed to load prediction image from {path_pred}")
    
    if ground_truth_img.shape != prediction_img.shape:
        raise ValueError(f"Image dimensions do not match: {ground_truth_img.shape} vs {prediction_img.shape}")
    
    # Normalize to [0, 1] since uint8
    ground_truth = ground_truth_img / 255.0
    prediction = prediction_img / 255.0
    
    # Convert numpy arrays to PyTorch tensors
    ground_truth_tensor = torch.from_numpy(ground_truth).float()
    prediction_tensor = torch.from_numpy(prediction).float()
       
    criterion = torch.nn.BCELoss(reduction=reduction)
    
    bce_loss = criterion(prediction_tensor, ground_truth_tensor)
    
    return bce_loss

def bce_loss_torch(path_gt, path_pred, reduction) -> torch.Tensor:
    """
    Calculate Binary Cross Entropy (BCE) loss between two black and white images using PyTorch.
    
    Args:
        ground_truth (torch.Tensor): Ground truth image containing a path (black and white).
        prediction (torch.Tensor): Prediction image generated by a model (black and white).
        reduction (str): Specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. Default: 'mean'.
        
    Returns:
        torch.Tensor: The BCE loss value between the two images.
    """
    if path_gt.shape != path_pred.shape:
        raise ValueError(f"Image dimensions do not match: {path_gt.shape} vs {path_pred.shape}")
    
    # Initialize BCE loss function with specified reduction
    criterion = torch.nn.BCELoss(reduction=reduction)
    
    # Calculate BCE loss
    bce_loss = criterion(path_pred, path_gt)
    
    return bce_loss

def bce_loss_logits(path_gt, path_pred) -> torch.Tensor:
    """
    Calculate Binary Cross Entropy (BCE) loss between two black and white images using PyTorch.
    
    Args:
        ground_truth (torch.Tensor): Ground truth image containing a path (black and white).
        prediction (torch.Tensor): Prediction image generated by a model (black and white).
        reduction (str): Specifies the reduction to apply to the output: 'none' | 'mean' | 'sum'. Default: 'mean'.
        
    Returns:
        torch.Tensor: The BCE loss value between the two images.
    """
    if path_gt.shape != path_pred.shape:
        raise ValueError(f"Image dimensions do not match: {path_gt.shape} vs {path_pred.shape}")
    
    # Initialize BCE loss function with specified reduction
    criterion = torch.nn.BCEWithLogitsLoss()
    
    # Calculate BCE loss
    bce_loss = criterion(path_pred, path_gt)
    
    return bce_loss
